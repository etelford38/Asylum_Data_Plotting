# -*- coding: utf-8 -*-
"""
Created on Thu Jun  1 15:51:16 2023

@author: Evan Telford (ejt2133@columbia.edu) and Maelle Kapfer (mak2294@columbia.edu)
"""
#%% Load pertinent packages
import pandas as pan
import igor.binarywave as igor
import matplotlib.pyplot as plt
import numpy as np
import os
import matplotlib as mt
from pathlib import Path
import shutil
import glob
import cv2
#%% IGOR loading and data analysis
#%% Define user functions for importing igor-type data generated by Jupiter AFMs
def getMetaData(dat):
    note = dat['wave']['note'].decode('ISO-8859-1')
    metaData = {}
    name = []
    val = []
    for line in note.split('\r'):
        name.append(line.split(':')[0])
        try:
            val.append(line.split(':')[1])
        except IndexError:
            val.append('nan')
    metaData = dict(zip(name,val))
    
    return metaData

def getData_Line(dat):
    data = dat['wave']['wData']
    Label = dat['wave']['labels'][1]
    Label = Label[1:]
    dat = np.zeros((len(Label),len(data[:,0])))
    dict_res = {}
    
    for i in range(len(Label)):
        dat[i] = data[:,i]
        
    for l,d in zip(Label,dat):
        dict_res[l] = d

    return Label, dict_res

def getData2D(dat):
    data = dat['wave']['wData']
    Label = dat['wave']['labels'][2]
    Label = Label[1:]
    dat = np.zeros((len(Label),len(data),len(data)))
    dict_res = {}
    
    for i in range(len(Label)):
        dat[i] = data[:,:,i]
        
    for l,d in zip(Label,dat):
        dict_res[l] = d
    
    return Label, dict_res

def line_correct(array,direction):
    me=np.mean(array)
    temp_array=array
    y, x = array.shape
    if direction=='vertical':
        for i in range(x):
            temp_x=array[:,i]
            temp_x=temp_x-np.mean(temp_x)
            temp_array[:,i]=temp_x
    elif direction=='horizontal':
        for i in range(y):
            temp_y=array[i,:]
            temp_y=temp_y-np.mean(temp_y)
            temp_array[i,:]=temp_y
    else:
        print('not a valid direction')
    return temp_array+me

def optimize_color(array):
    mo=np.median(array)
    sd=np.std(array)
    return mo, 1.5*sd

def oneFFT(data):
    f = np.fft.fft2(data)
    fshift = np.fft.fftshift(f)
    absFFT = np.abs(fshift) + 1e-10
    magnitude_spectrum = np.log(absFFT)
    magnitude_spectrum = magnitude_spectrum - np.mean(magnitude_spectrum)
    
    # Remove the zero-peak and the vertical/horizontal noise lines
    magnitude_spectrum_size = magnitude_spectrum.shape[0]
    magnitude_spectrum[int(magnitude_spectrum_size//2),:] = 0#np.std(magnitude_spectrum)
    magnitude_spectrum[:,int(magnitude_spectrum_size//2)] = 0#np.std(magnitude_spectrum)
    
    magnitude_spectrum_norm = magnitude_spectrum - np.min(magnitude_spectrum)
    magnitude_spectrum_norm = (magnitude_spectrum_norm / np.max(magnitude_spectrum_norm)*255).astype(np.uint8)
    
    magnitude_spectrum_norm = cv2.medianBlur(magnitude_spectrum_norm,1)
    
    test = magnitude_spectrum_norm.copy()
    
    return test

def pad_with(vector, pad_width, iaxis, kwargs):
    pad_value = kwargs.get('padder', 0)
    vector[:pad_width[0]] = pad_value
    vector[-pad_width[1]:] = pad_value
#%% Functions for identifying data types and sorting data
def test_dimension(fname):
    dat = igor.load(fname)
    if not dat['wave']['labels'][2]:
        dim=1
    else:
        dim=2
    
    return dim
    
def load_data(fname):
    dat = igor.load(fname)
    dim=test_dimension(fname)
    if dim>1:
        label, dat1= getData2D(dat)
    else:
        label, dat1= getData_Line(dat)
    
    return label,dat1,dim

def identify_data_type(fname):
    label,data,dim=load_data(fname)
    if dim<2: #it's an IV or FD curves
        if len(partial(label,'Cur'))>0:
            #can be IV or FD while measuring current
            if len(partial(label,'Drive'))>0:
                Scan_type='IV'
            else:
                Scan_type='FD-I'
        elif len(partial(label,'Defl'))>0 and len(partial(label,'Bias'))>0:
            #probably just FD curves without current
            Scan_type='FD'
        else:
            Scan_type='not defined'
    else:
        if len(partial(label,'Friction'))>0:
            Scan_type='LFM'
        elif len(partial(label,'Current'))>0:
            Scan_type='CAFM'
        elif len(partial(label,'Height'))>0:
            if len(partial(label,'Phase'))>0:
                Scan_type='Tap'
            elif len(partial(label,'Deflection'))>0:
                Scan_type='Contact'
            else:
                Scan_type='not defined'
        else:
            Scan_type='not defined'
    
    return Scan_type

def extract_data_headers(fname,headers):
    label,dat,dim=load_data(fname)
    df=pan.DataFrame()
    for i,f in enumerate(headers):
        index=partial(label,f)
        if len(index)>1:
            print(str(f)+' key is not unique')
        else:
            pass
        temp_label=index[0]
        temp_data=dat[temp_label]
        df[temp_label]=np.array(temp_data[0])
        
    return df

def extract_proper_header(fname,header):
    label,dat,dim=load_data(fname)
    prop_headers=partial(label,header)
    if len(prop_headers)>1:
        print(str(header)+' key is not unique')
    else:
        pass
    return prop_headers[0]

def sort_files(key):
    #sets up the basic directory
    dir_path = os.path.dirname(os.path.realpath(__file__))
    dir_path=Path(dir_path)
    #load data
    names=dir_path.glob(key)    
    #identifying and moving files
    for f in names:
        data_type=identify_data_type(f)
        save_path = Path(dir_path)/data_type
        if not os.path.exists(save_path):
           os.makedirs(save_path)
        base_name=os.path.basename(f)
        shutil.move(f,save_path/base_name)
        print('sorted '+str(os.path.split(f)[1]))
        
def run_analysis(directory):   
    headers=[['HeightRe','AmplitudeRe','PhaseRe'],
                       ['HeightTr','CurrentTr','Current2Tr'],
                       ['HeightTr','DeflectionTr','ZSensorTr'],
                       ['HeightRe','DeflectionRe','LateralRe'],
                       ['None'],
                       ['None'],
                       ['None'],
                       ['None']]
    #change to directory and load data files
    os.chdir(directory)
    if os.path.exists(directory/"Raw data"):
        directory_temp=directory/"Raw data"
        os.chdir(directory_temp)
        names_for_loop=glob.glob('*.ibw*')
    else:
        names_for_loop=glob.glob('*.ibw*')
    #check if there are files and what type they are
    if len(names_for_loop)>0:
        data_type=identify_data_type(names_for_loop[0])
    else:
        data_type='None'
        print('no files in '+str(directory))
     
    if data_type=='Tap':
        Tap(directory,headers[0])
        print('Analyzed '+str(data_type)+' data')
    elif data_type=='CAFM':
        CAFM(directory,headers[1])
        print('Analyzed '+str(data_type)+' data')
    elif data_type=='Contact':
        Contact(directory,headers[2])
        print('Analyzed '+str(data_type)+' data')
    elif data_type=='LFM':
        LFM(directory,headers[3])
        print('Analyzed '+str(data_type)+' data')
    elif data_type=='FD-I':
        FD(directory,headers[4])
        print('Analyzed '+str(data_type)+' data')
    elif data_type=='IV':
        IV(directory,headers[5])
        print('Analyzed '+str(data_type)+' data')
    elif data_type=='FD':
        FD(directory,headers[6])
        print('Analyzed '+str(data_type)+' data')
    elif data_type=='None':
        print('data type not in library')
    else:
        pass

def master_analysis():
    keys=['Tap','CAFM','Contact','LFM','FD-I','IV','FD']
    #sort files first
    sort_files('*.ibw*')
    #identify data directory
    dir_path = os.path.dirname(os.path.realpath(__file__))
    dir_path=Path(dir_path)
    #check for the existence of folders:
    for i in keys:
        save_path=dir_path/i
        if os.path.exists(save_path):
            os.chdir(save_path)
            run_analysis(save_path)
        else:
            pass
        os.chdir(dir_path)
    
def partial(lst, query):
    return [s for s in lst if query in str(s)]
#%% Functions for each analysis type
def CAFM(directory,headers):
    #sets up the basic directory
    dir_path=directory
    names=dir_path.glob('*.ibw')
    
    #creates Raw data folder AND moves the files
    name_path=Path(dir_path)/"Raw data"
    if not os.path.exists(name_path):
       os.makedirs(name_path)
    
    for m in names:
        base_name=os.path.basename(m)
        shutil.move(m,name_path/base_name)
    
    #change directory to Raw data and load the files
    os.chdir(name_path)
    names=name_path.glob('*.ibw')
    
    for i,k in enumerate(names): 
        for l in range(2):
            data_file = k
            font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 6}
            mt.rc('font', **font)
            mt.rcParams['pdf.fonttype'] = 42
            mt.rcParams['ps.fonttype'] = 42
            mt.rcParams['font.family'] = 'Arial'
            fig, axes = plt.subplots(nrows=1,ncols=3,figsize=(7,4),gridspec_kw={'wspace':0.5,'hspace':0.0},dpi=300)
            plt.rcParams['text.color'] = 'k'
            plt.rcParams['axes.labelcolor'] = 'k'
            plt.rcParams['xtick.color'] = 'k'
            plt.rcParams['ytick.color'] = 'k'
            dat = igor.load(data_file)
            metaData = {}
            metaData = getMetaData(dat)
            label, dat= getData2D(dat)
            scansize=metaData['ScanSize'].split('@')[0]
            scane=str(len(metaData['ScanSize'].split('@'))-1)
            voltage=metaData['SurfaceVoltage'].split('@')[0]
            voltagee=str(len(metaData['SurfaceVoltage'].split('@'))-1)
            deflection=metaData['DeflectionSetpointVolts'].split('@')[0]
            deflectione=str(len(metaData['DeflectionSetpointVolts'].split('@'))-1)
            scanrate=metaData['ScanRate'].split('@')[0]
            scanratee=str(len(metaData['ScanRate'].split('@'))-1)
            title_text_t=['$Height (nm), F=$'+deflection+'$V$ - Errors: '+scane+voltagee+deflectione+scanratee,'$Current (nA),V=$'+voltage+'$V$','$Current (nA),V=$'+voltage+'$V$']
    
            AFMZ=dat[partial(label,headers[0])[0]]*1e9
            AFMD=dat[partial(label,headers[1])[0]]*1e9
            AFMI=dat[partial(label,headers[2])[0]]*1e9
            
            for i,f in enumerate(axes):
                f.spines['left'].set_color('k')
                f.spines['right'].set_color('k')
                f.spines['bottom'].set_color('k')
                f.spines['top'].set_color('k')
                f.spines['left'].set_linewidth(0.5)
                f.spines['right'].set_linewidth(0.5)
                f.spines['bottom'].set_linewidth(0.5)
                f.spines['top'].set_linewidth(0.5)
                f.tick_params(width=0.5,length=2.0)
                f.set_title(title_text_t[i],fontsize=6, pad=5)
                f.tick_params(direction="in")
                f.yaxis.set_ticks_position(position='both')
                f.xaxis.set_ticks_position(position='both')
                f.set_xlabel('$x (\mu m)$', labelpad=0.1)
                f.set_ylabel('$y (\mu m)$', labelpad=0.1)
            
            if l==0:
                pass
            if l==1:
                AFMZ=line_correct(AFMZ,'vertical')
                AFMD=line_correct(AFMD,'vertical')
                AFMI=line_correct(AFMI,'vertical')
    
            AFMZmo, AMFZsd = optimize_color(AFMZ)
            AFMDmo, AMFDsd = optimize_color(AFMD)
            AFMImo, AMFIsd = optimize_color(AFMI)
                
            f1=axes[0].imshow((AFMZ),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6],cmap='Greys_r',vmin=AFMZmo-AMFZsd,vmax=AFMZmo+AMFZsd)
            c1=fig.colorbar(f1, ax=axes[0],fraction=0.046, pad=0.04)
            c1.outline.set_linewidth(0.5)
            f2=axes[1].imshow((AFMD),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='Blues_r',vmin=AFMDmo-AMFDsd,vmax=AFMDmo+AMFDsd)
            c2=fig.colorbar(f2, ax=axes[1],fraction=0.046, pad=0.04)
            c2.outline.set_linewidth(0.5)
            f3=axes[2].imshow((AFMI),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='Blues_r',vmin=AFMImo-AMFIsd,vmax=AFMImo+AMFIsd)
            c3=fig.colorbar(f3, ax=axes[2],fraction=0.046, pad=0.04)
            c3.outline.set_linewidth(0.5)
            
            if l==0:
                save_path = Path(dir_path)/"Images uncorrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_uncorrected.png', bbox_inches='tight',dpi=600)   
            if l==1:
                save_path = Path(dir_path)/"Images line corrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_line_corrected.png', bbox_inches='tight',dpi=600)  
            plt.show()
    
def FD(directory,headers):
    xl='$x (nm)$'
    x=b'Raw'
    #sets up the basic directory
    dir_path=directory
    names=dir_path.glob('*.ibw')

    #creates Raw data folder AND moves the files
    name_path=Path(dir_path)/"Raw data"
    if not os.path.exists(name_path):
       os.makedirs(name_path)

    for m in names:
        base_name=os.path.basename(m)
        shutil.move(m,name_path/base_name)

    #change directory to Raw data and load the files
    os.chdir(name_path)
    names=name_path.glob('*.ibw')

    for i,j in enumerate(names):  
        font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 8}
        mt.rc('font', **font)
        mt.rcParams['pdf.fonttype'] = 42
        mt.rcParams['ps.fonttype'] = 42
        mt.rcParams['font.family'] = 'Arial'
        fig,axes = plt.subplots(nrows=1,ncols=2,figsize=(7,3),gridspec_kw={'wspace':0.4,'hspace':0.0},dpi=300)
        plt.rcParams['text.color'] = 'k'
        plt.rcParams['axes.labelcolor'] = 'k'
        plt.rcParams['xtick.color'] = 'k'
        plt.rcParams['ytick.color'] = 'k'
        plt.rcParams["axes.axisbelow"] = False
        
        for l in range(2):
            f=axes[l]
            g=f.twinx()
            g.set_zorder(0)
            f.set_zorder(1)
            f.spines['left'].set_color('k')
            f.spines['right'].set_color('k')
            f.spines['bottom'].set_color('k')
            f.spines['top'].set_color('k')
            f.spines['left'].set_linewidth(0.5)
            f.spines['right'].set_linewidth(0.5)
            f.spines['bottom'].set_linewidth(0.5)
            f.spines['top'].set_linewidth(0.5)
            f.tick_params(width=0.5)
            dat = igor.load(j)
            metaData = {}
            metaData = getMetaData(dat)
            label, dact= getData_Line(dat)
            offset=np.where(dact[b'Defl']==np.min(dact[b'Defl']))
            x_temp=(dact[x]-dact[x][offset[0]])*1e9
            if l==0:
                I_temp=(dact[b'Cur']-np.mean(dact[b'Cur'][0:100]))*1e9
            else:
                I_temp=(dact[b'Curr2']-np.mean(dact[b'Curr2'][0:100]))*1e9
            F_temp=(dact[b'Defl']-np.mean(dact[b'Defl'][0:100]))*1e9
            
            f.plot(x_temp, F_temp ,'ko-',markersize=1,linewidth=1)
            f.set_xlabel(xl,labelpad=0.0)
            f.set_ylabel('$F (nN)$',labelpad=0.0)
            g.plot(x_temp,I_temp,'ro-',markersize=1,linewidth=1)
            g.set_xlabel(xl,labelpad=0.1)
            g.set_ylabel('$I (nA)$',labelpad=0.0)
            
            voltage=metaData['SurfaceVoltage'].split('@')[0]
            voltagee=str(len(metaData['SurfaceVoltage'].split('@'))-1)
            f.set_title('$V=$'+voltage+'$V$ - Errors: '+voltagee,fontsize=8,pad=3)

            f.patch.set_visible(False)
            f.tick_params(direction="in")
            g.tick_params(direction="in")
            f.xaxis.set_ticks_position(position='both')
            f.set_xlim(np.min(x_temp),np.max(x_temp))
            f.set_xlim(-100,np.max(x_temp))
        save_path = Path(dir_path)/"Plots uncorrected"
        fname=j
        fname=os.path.split(fname)[1]
        if not os.path.exists(save_path):
           os.makedirs(save_path)
        os.chdir(save_path)
        plt.savefig(fname[:-4]+'_figure_uncorrected.png', bbox_inches='tight',dpi=600)   
        plt.show()
        
def Contact(directory,headers):
    #sets up the basic directory
    dir_path=directory
    names=dir_path.glob('*.ibw')

    #creates Raw data folder AND moves the files
    name_path=Path(dir_path)/"Raw data"
    if not os.path.exists(name_path):
       os.makedirs(name_path)

    for m in names:
        base_name=os.path.basename(m)
        shutil.move(m,name_path/base_name)

    #change directory to Raw data and load the files
    os.chdir(name_path)
    names=name_path.glob('*.ibw')

    for i,k in enumerate(names): 
        for l in range(2):
            data_file = k
            font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 6}
            mt.rc('font', **font)
            mt.rcParams['pdf.fonttype'] = 42
            mt.rcParams['ps.fonttype'] = 42
            mt.rcParams['font.family'] = 'Arial'
            fig, axes = plt.subplots(nrows=1,ncols=3,figsize=(7,4),gridspec_kw={'wspace':0.5,'hspace':0.0},dpi=300)
            plt.rcParams['text.color'] = 'k'
            plt.rcParams['axes.labelcolor'] = 'k'
            plt.rcParams['xtick.color'] = 'k'
            plt.rcParams['ytick.color'] = 'k'
            dat = igor.load(data_file)
            metaData = {}
            metaData = getMetaData(dat)
            label, dat= getData2D(dat)
            scansize=metaData['ScanSize'].split('@')[0]
            scane=str(len(metaData['ScanSize'].split('@'))-1)
            # voltage=metaData['SurfaceVoltage'].split('@')[0]
            # voltagee=str(len(metaData['SurfaceVoltage'].split('@'))-1)
            deflection=metaData['DeflectionSetpointVolts'].split('@')[0]
            deflectione=str(len(metaData['DeflectionSetpointVolts'].split('@'))-1)
            scanrate=metaData['ScanRate'].split('@')[0]
            scanratee=str(len(metaData['ScanRate'].split('@'))-1)
            title_text_t=['Height (nm) - Errors: '+scane+deflectione+scanratee,'Amplitude (nV)','Z Sensor (nm)']

            AFMZ=dat[partial(label,headers[0])[0]]*1e9
            AFMD=dat[partial(label,headers[1])[0]]*1e9
            AFMI=dat[partial(label,headers[2])[0]]*1e9
            
            for i,f in enumerate(axes):
                f.spines['left'].set_color('k')
                f.spines['right'].set_color('k')
                f.spines['bottom'].set_color('k')
                f.spines['top'].set_color('k')
                f.spines['left'].set_linewidth(0.5)
                f.spines['right'].set_linewidth(0.5)
                f.spines['bottom'].set_linewidth(0.5)
                f.spines['top'].set_linewidth(0.5)
                f.tick_params(width=0.5,length=2.0)
                f.set_title(title_text_t[i],fontsize=6, pad=5)
                f.tick_params(direction="in")
                f.yaxis.set_ticks_position(position='both')
                f.xaxis.set_ticks_position(position='both')
                f.set_xlabel('$x (\mu m)$', labelpad=0.1)
                f.set_ylabel('$y (\mu m)$', labelpad=0.1)
            
            if l==0:
                pass
            if l==1:
                AFMZ=line_correct(AFMZ,'vertical')
                AFMD=line_correct(AFMD,'vertical')
                AFMI=line_correct(AFMI,'vertical')

            AFMZmo, AMFZsd = optimize_color(AFMZ)
            AFMDmo, AMFDsd = optimize_color(AFMD)
            AFMImo, AMFIsd = optimize_color(AFMI)
                
            f1=axes[0].imshow((AFMZ),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6],cmap='Greys_r',vmin=AFMZmo-AMFZsd,vmax=AFMZmo+AMFZsd)
            c1=fig.colorbar(f1, ax=axes[0],fraction=0.046, pad=0.04)
            c1.outline.set_linewidth(0.5)
            f2=axes[1].imshow((AFMD),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='Blues_r',vmin=AFMDmo-AMFDsd,vmax=AFMDmo+AMFDsd)
            c2=fig.colorbar(f2, ax=axes[1],fraction=0.046, pad=0.04)
            c2.outline.set_linewidth(0.5)
            f3=axes[2].imshow((AFMI),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='hot',vmin=AFMImo-AMFIsd,vmax=AFMImo+AMFIsd)
            c3=fig.colorbar(f3, ax=axes[2],fraction=0.046, pad=0.04)
            c3.outline.set_linewidth(0.5)
            
            if l==0:
                save_path = Path(dir_path)/"Images uncorrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_uncorrected.png', bbox_inches='tight',dpi=600)   
            if l==1:
                save_path = Path(dir_path)/"Images line corrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_line_corrected.png', bbox_inches='tight',dpi=600)  
            plt.show()
            
def IV(directory,headers):
    xl='$V (V)$'
    x=b'Bias'
    #sets up the basic directory
    dir_path=directory
    names=dir_path.glob('*.ibw')

    #creates Raw data folder AND moves the files
    name_path=Path(dir_path)/"Raw data"
    if not os.path.exists(name_path):
       os.makedirs(name_path)

    for m in names:
        base_name=os.path.basename(m)
        shutil.move(m,name_path/base_name)

    #change directory to Raw data and load the files
    os.chdir(name_path)
    names=name_path.glob('*.ibw')

    for i,j in enumerate(names):  
        font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 8}
        mt.rc('font', **font)
        mt.rcParams['pdf.fonttype'] = 42
        mt.rcParams['ps.fonttype'] = 42
        mt.rcParams['font.family'] = 'Arial'
        fig,axes = plt.subplots(nrows=1,ncols=2,figsize=(7,3),gridspec_kw={'wspace':0.4,'hspace':0.0},dpi=600)
        plt.rcParams['text.color'] = 'k'
        plt.rcParams['axes.labelcolor'] = 'k'
        plt.rcParams['xtick.color'] = 'k'
        plt.rcParams['ytick.color'] = 'k'
        
        for l in range(2):
            f=axes[l]
            g=f.twinx()
            g.set_zorder(1)
            f.set_zorder(0)
            f.spines['left'].set_color('k')
            f.spines['right'].set_color('k')
            f.spines['bottom'].set_color('k')
            f.spines['top'].set_color('k')
            f.spines['left'].set_linewidth(0.5)
            f.spines['right'].set_linewidth(0.5)
            f.spines['bottom'].set_linewidth(0.5)
            f.spines['top'].set_linewidth(0.5)
            f.tick_params(width=0.5)
            dat = igor.load(j)
            metaData = {}
            metaData = getMetaData(dat)
            label, dact= getData_Line(dat)
            
            x_temp=(dact[x])
            if l==0:
                I_temp=(dact[b'Cur']-dact[b'Cur'].mean())*1e9
            else:
                I_temp=(dact[b'Curr2']-dact[b'Curr2'].mean())*1e9
            F_temp=(dact[b'Defl']-np.mean(dact[b'Defl']))*1e9
            
            f.plot(x_temp, F_temp ,'ko-',markersize=1,linewidth=1)
            f.set_xlabel(xl,labelpad=0.0)
            f.set_ylabel('$\Delta F (nN)$',labelpad=0.0)
            f.set_ylim(-10*F_temp.max(),10*F_temp.max())
            g.plot(x_temp,I_temp,'ro-',markersize=1,linewidth=1)
            g.set_xlabel(xl,labelpad=0.1)
            g.set_ylabel('$I (nA)$',labelpad=0.0)
            
            voltage=metaData['DeflectionSetpointVolts'].split('@')[0]
            voltagee=str(len(metaData['DeflectionSetpointVolts'].split('@'))-1)
            f.set_title('$F=$'+voltage+'$V$ - Errors: '+voltagee,fontsize=8,pad=3)

            f.patch.set_visible(False)
            f.tick_params(direction="in")
            g.tick_params(direction="in")
            f.xaxis.set_ticks_position(position='both')
            f.set_xlim(np.min(x_temp),np.max(x_temp))
        save_path = Path(dir_path)/"Plots uncorrected"
        fname=j
        fname=os.path.split(fname)[1]
        if not os.path.exists(save_path):
           os.makedirs(save_path)
        os.chdir(save_path)
        plt.savefig(fname[:-4]+'_figure_uncorrected.png', bbox_inches='tight',dpi=600)   
        plt.show()
        
def Tap(directory,headers):
    #sets up the basic directory
    dir_path=directory
    names=dir_path.glob('*.ibw')
    #creates Raw data folder AND moves the files
    name_path=Path(dir_path)/"Raw data"
    if not os.path.exists(name_path):
       os.makedirs(name_path)

    for m in names:
        base_name=os.path.basename(m)
        shutil.move(m,name_path/base_name)

    #change directory to Raw data and load the files
    os.chdir(name_path)
    names=name_path.glob('*.ibw')

    for i,k in enumerate(names): 
        for l in range(2):
            data_file = k
            font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 6}
            mt.rc('font', **font)
            mt.rcParams['pdf.fonttype'] = 42
            mt.rcParams['ps.fonttype'] = 42
            mt.rcParams['font.family'] = 'Arial'
            fig, axes = plt.subplots(nrows=1,ncols=3,figsize=(7,4),gridspec_kw={'wspace':0.5,'hspace':0.0},dpi=300)
            plt.rcParams['text.color'] = 'k'
            plt.rcParams['axes.labelcolor'] = 'k'
            plt.rcParams['xtick.color'] = 'k'
            plt.rcParams['ytick.color'] = 'k'
            dat = igor.load(data_file)
            metaData = {}
            metaData = getMetaData(dat)
            label, dat= getData2D(dat)
          
            scansize=metaData['ScanSize'].split('@')[0]
            scane=str(len(metaData['ScanSize'].split('@'))-1)
            voltage=metaData['SurfaceVoltage'].split('@')[0]
            voltagee=str(len(metaData['SurfaceVoltage'].split('@'))-1)
            deflection=metaData['DeflectionSetpointVolts'].split('@')[0]
            deflectione=str(len(metaData['DeflectionSetpointVolts'].split('@'))-1)
            scanrate=metaData['ScanRate'].split('@')[0]
            scanratee=str(len(metaData['ScanRate'].split('@'))-1)
            
            title_text_t=['$Height (nm)$ - Errors: '+scane+voltagee+deflectione+scanratee,'Deflection Error','Phase']
            AFMZ=dat[partial(label,headers[0])[0]]*1e9
            AFMD=dat[partial(label,headers[1])[0]]*1e9
            AFMI=dat[partial(label,headers[2])[0]]
            
            for i,f in enumerate(axes):
                f.spines['left'].set_color('k')
                f.spines['right'].set_color('k')
                f.spines['bottom'].set_color('k')
                f.spines['top'].set_color('k')
                f.spines['left'].set_linewidth(0.5)
                f.spines['right'].set_linewidth(0.5)
                f.spines['bottom'].set_linewidth(0.5)
                f.spines['top'].set_linewidth(0.5)
                f.tick_params(width=0.5,length=2.0)
                f.set_title(title_text_t[i],fontsize=6, pad=5)
                f.tick_params(direction="in")
                f.yaxis.set_ticks_position(position='both')
                f.xaxis.set_ticks_position(position='both')
                f.set_xlabel('$x (\mu m)$', labelpad=0.1)
                f.set_ylabel('$y (\mu m)$', labelpad=0.1)
            
            if l==0:
                pass
            if l==1:
                AFMZ=line_correct(AFMZ,'vertical')
                AFMD=line_correct(AFMD,'vertical')
                AFMI=line_correct(AFMI,'vertical')      
                
            AFMZmo, AMFZsd = optimize_color(AFMZ)
            AFMDmo, AMFDsd = optimize_color(AFMD)
            AFMImo, AMFIsd = optimize_color(AFMI)
                
            f1=axes[0].imshow((AFMZ),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6],cmap='Greys_r',vmin=AFMZmo-AMFZsd,vmax=AFMZmo+AMFZsd)
            c1=fig.colorbar(f1, ax=axes[0],fraction=0.046, pad=0.04)
            c1.outline.set_linewidth(0.5)
            f2=axes[1].imshow((AFMD),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='Blues_r',vmin=AFMDmo-AMFDsd,vmax=AFMDmo+AMFDsd)
            c2=fig.colorbar(f2, ax=axes[1],fraction=0.046, pad=0.04)
            c2.outline.set_linewidth(0.5)
            f3=axes[2].imshow((AFMI),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='Oranges_r',vmin=AFMImo-AMFIsd,vmax=AFMImo+AMFIsd)
            c3=fig.colorbar(f3, ax=axes[2],fraction=0.046, pad=0.04)
            c3.outline.set_linewidth(0.5)
            
            if l==0:
                save_path = Path(dir_path)/"Images uncorrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_uncorrected.png', bbox_inches='tight',dpi=600)   
            if l==1:
                save_path = Path(dir_path)/"Images line corrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_line_corrected.png', bbox_inches='tight',dpi=600)   

            plt.show()
            
def CAFM_FFT(directory,headers):
    #sets up the basic directory
    dir_path=directory
    names=dir_path.glob('*.ibw')

    #creates Raw data folder AND moves the files
    name_path=Path(dir_path)/"Raw data"
    if not os.path.exists(name_path):
       os.makedirs(name_path)

    for m in names:
        base_name=os.path.basename(m)
        shutil.move(m,name_path/base_name)

    #change directory to Raw data and load the files
    os.chdir(name_path)
    names=name_path.glob('*.ibw')

    for i,k in enumerate(names): 
        for l in range(1):
            data_file = k
            font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 6}
            mt.rc('font', **font)
            mt.rcParams['pdf.fonttype'] = 42
            mt.rcParams['ps.fonttype'] = 42
            mt.rcParams['font.family'] = 'Arial'
            fig, axes = plt.subplots(nrows=1,ncols=2,figsize=(7,5),gridspec_kw={'wspace':0.2,'hspace':0.0},dpi=300)
            plt.rcParams['text.color'] = 'k'
            plt.rcParams['axes.labelcolor'] = 'k'
            plt.rcParams['xtick.color'] = 'k'
            plt.rcParams['ytick.color'] = 'k'
            dat = igor.load(data_file)
            metaData = {}
            metaData = getMetaData(dat)
            label, dat= getData2D(dat)
            scansize=metaData['ScanSize'].split('@')[0]
            scane=str(len(metaData['ScanSize'].split('@'))-1)
            voltage=metaData['SurfaceVoltage'].split('@')[0]
            voltagee=str(len(metaData['SurfaceVoltage'].split('@'))-1)
            deflection=metaData['DeflectionSetpointVolts'].split('@')[0]
            deflectione=str(len(metaData['DeflectionSetpointVolts'].split('@'))-1)
            scanrate=metaData['ScanRate'].split('@')[0]
            scanratee=str(len(metaData['ScanRate'].split('@'))-1)
            title_text_t=['$Current (nA),V=$'+voltage+'$V$','$FFT[Current] (a.u.)$']
            AFMZ=dat[partial(label,headers[0])[0]]*1e9
            AFMD=dat[partial(label,headers[1])[0]]*1e9
            
            for i,f in enumerate(axes):
                f.spines['left'].set_color('k')
                f.spines['right'].set_color('k')
                f.spines['bottom'].set_color('k')
                f.spines['top'].set_color('k')
                f.spines['left'].set_linewidth(0.5)
                f.spines['right'].set_linewidth(0.5)
                f.spines['bottom'].set_linewidth(0.5)
                f.spines['top'].set_linewidth(0.5)
                f.tick_params(width=0.5,length=2.0)
                f.set_title(title_text_t[i],fontsize=6, pad=5)
                f.tick_params(direction="in")
                f.yaxis.set_ticks_position(position='both')
                f.xaxis.set_ticks_position(position='both')
                if i==1:
                    f.set_xlabel('$x^{-1} (nm^{-1})$', labelpad=0.1)
                    f.set_ylabel('$y^{-1} (nm^{-1})$', labelpad=0.1)
                else:
                    f.set_xlabel('$x (\mu m)$', labelpad=0.1)
                    f.set_ylabel('$y (\mu m)$', labelpad=0.1)
                    
            if l==0:
                AFMZ=line_correct(AFMZ,'vertical')
                AFMD=line_correct(AFMD,'vertical')
            
            AFMD=AFMD-np.mean(AFMD)
            
            AFMZmo, AMFZsd = optimize_color(AFMZ)
            AFMDmo, AMFDsd = optimize_color(AFMD)
    ########################################################################################################################################################################
            #FFT stuff
            x_lines = float(metaData['PointsLines'])
            y_lines = float(metaData['ScanLines'])
            x_real = float(scansize)
            y_real=x_real
            nmPrPix = (x_real/1e-9)/(x_lines)
            FFTextent = 1/(nmPrPix*2)
            FFTpixSize = FFTextent / (x_lines*0.5)
    ########################################################################################################################################################################
            #FFT padding if desired
            data=AFMD
            padding = int(x_lines/2)
            data_pad = np.pad(data, padding, pad_with)
            
            #Recalculate sizes for padding
            x_lines_pad = x_lines + padding*2
            y_lines_pad = y_lines + padding*2
            
            x_real_pad = x_real + padding*2*nmPrPix
            y_real_pad = y_real + padding*2*nmPrPix
            
            nmPrPix_pad = x_real_pad/x_lines_pad
            FFTextent_pad = FFTextent
            FFTpixSize_pad = FFTextent_pad / (x_lines_pad*0.5)
            zoomFactor_pad = 8
            
            ymin_pad,ymax_pad = int(y_lines_pad*(zoomFactor_pad-1)/(zoomFactor_pad*2)),int(y_lines_pad*(zoomFactor_pad+1)/(zoomFactor_pad*2))
            xmin_pad,xmax_pad = int(x_lines_pad*(zoomFactor_pad-1)/(zoomFactor_pad*2)),int(x_lines_pad*(zoomFactor_pad+1)/(zoomFactor_pad*2))
            
            subFFT_pad = oneFFT(data_pad)[ymin_pad:ymax_pad,xmin_pad:xmax_pad]
    ########################################################################################################################################################################
            f2=axes[0].imshow((data),extent = [0,float(scansize)*1e6*(x_lines)/x_lines,0,float(scansize)*1e6*(x_lines)/x_lines], cmap='Blues_r',vmin=AFMDmo-AMFDsd,vmax=AFMDmo+AMFDsd)
            c2=fig.colorbar(f2, ax=axes[0],fraction=0.046, pad=0.04,ticks=[])
            c2.outline.set_linewidth(0.5)
            
            f3=axes[1].imshow((subFFT_pad),
                              extent = [-FFTextent_pad/zoomFactor_pad,FFTextent_pad/zoomFactor_pad,-FFTextent_pad/zoomFactor_pad,FFTextent_pad/zoomFactor_pad],
                              cmap='Greens',
                              vmin=np.max(subFFT_pad)*0.75,vmax=0.9*np.max(subFFT_pad))
            c3=fig.colorbar(f3, ax=axes[1],fraction=0.046, pad=0.04,ticks=[])
            c3.outline.set_linewidth(0.5)     
            
            save_path = Path(dir_path)/"FFT analysis publication quality"
            fname=k
            fname=os.path.split(fname)[1]
            if not os.path.exists(save_path):
               os.makedirs(save_path)
            os.chdir(save_path)
            plt.savefig(fname[:-4]+'_figure_padded.png', bbox_inches='tight',dpi=600)  
            plt.show()
              
def LFM(directory,headers):
    #sets up the basic directory
    dir_path=directory
    names=dir_path.glob('*.ibw')

    #creates Raw data folder AND moves the files
    name_path=Path(dir_path)/"Raw data"
    if not os.path.exists(name_path):
       os.makedirs(name_path)

    for m in names:
        base_name=os.path.basename(m)
        shutil.move(m,name_path/base_name)

    #change directory to Raw data and load the files
    os.chdir(name_path)
    names=name_path.glob('*.ibw')

    for i,k in enumerate(names): 
        for l in range(2):
            data_file = k
            font = {'family' : 'normal',
                'weight' : 'normal',
                'size'   : 6}
            mt.rc('font', **font)
            mt.rcParams['pdf.fonttype'] = 42
            mt.rcParams['ps.fonttype'] = 42
            mt.rcParams['font.family'] = 'Arial'
            fig, axes = plt.subplots(nrows=1,ncols=3,figsize=(7,4),gridspec_kw={'wspace':0.5,'hspace':0.0},dpi=300)
            plt.rcParams['text.color'] = 'k'
            plt.rcParams['axes.labelcolor'] = 'k'
            plt.rcParams['xtick.color'] = 'k'
            plt.rcParams['ytick.color'] = 'k'
            dat = igor.load(data_file)
            metaData = {}
            metaData = getMetaData(dat)
            label, dat= getData2D(dat)
            scansize=metaData['ScanSize'].split('@')[0]
            scane=str(len(metaData['ScanSize'].split('@'))-1)
            # voltage=metaData['SurfaceVoltage'].split('@')[0]
            # voltagee=str(len(metaData['SurfaceVoltage'].split('@'))-1)
            deflection=metaData['DeflectionSetpointVolts'].split('@')[0]
            deflectione=str(len(metaData['DeflectionSetpointVolts'].split('@'))-1)
            scanrate=metaData['ScanRate'].split('@')[0]
            scanratee=str(len(metaData['ScanRate'].split('@'))-1)
            title_text_t=['Height (nm) - Errors: '+scane+deflectione+scanratee,'Amplitude (nV)','Lateral Deflection (V), '+'$V=$'+str(deflection)+' V']

            AFMZ=dat[partial(label,headers[0])[0]]*1e9
            AFMD=dat[partial(label,headers[1])[0]]*1e9
            AFMI=dat[partial(label,headers[2])[0]]
            
            for i,f in enumerate(axes):
                f.spines['left'].set_color('k')
                f.spines['right'].set_color('k')
                f.spines['bottom'].set_color('k')
                f.spines['top'].set_color('k')
                f.spines['left'].set_linewidth(0.5)
                f.spines['right'].set_linewidth(0.5)
                f.spines['bottom'].set_linewidth(0.5)
                f.spines['top'].set_linewidth(0.5)
                f.tick_params(width=0.5,length=2.0)
                f.set_title(title_text_t[i],fontsize=6, pad=5)
                f.tick_params(direction="in")
                f.yaxis.set_ticks_position(position='both')
                f.xaxis.set_ticks_position(position='both')
                f.set_xlabel('$x (\mu m)$', labelpad=0.1)
                f.set_ylabel('$y (\mu m)$', labelpad=0.1)
            
            if l==0:
                pass
            if l==1:
                AFMZ=line_correct(AFMZ,'vertical')
                AFMD=line_correct(AFMD,'vertical')
                AFMI=line_correct(AFMI,'vertical')

            AFMZmo, AMFZsd = optimize_color(AFMZ)
            AFMDmo, AMFDsd = optimize_color(AFMD)
            AFMImo, AMFIsd = optimize_color(AFMI)
                
            f1=axes[0].imshow((AFMZ),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6],cmap='Greys_r',vmin=AFMZmo-AMFZsd,vmax=AFMZmo+AMFZsd)
            c1=fig.colorbar(f1, ax=axes[0],fraction=0.046, pad=0.04)
            c1.outline.set_linewidth(0.5)
            f2=axes[1].imshow((AFMD),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='Blues_r',vmin=AFMDmo-AMFDsd,vmax=AFMDmo+AMFDsd)
            c2=fig.colorbar(f2, ax=axes[1],fraction=0.046, pad=0.04)
            c2.outline.set_linewidth(0.5)
            f3=axes[2].imshow((AFMI),extent = [0,float(scansize)*1e6,0,float(scansize)*1e6], cmap='hot',vmin=AFMImo-AMFIsd,vmax=AFMImo+AMFIsd)
            c3=fig.colorbar(f3, ax=axes[2],fraction=0.046, pad=0.04)
            c3.outline.set_linewidth(0.5)
            
            if l==0:
                save_path = Path(dir_path)/"Images uncorrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_uncorrected.png', bbox_inches='tight',dpi=600)   
            if l==1:
                save_path = Path(dir_path)/"Images line corrected"
                fname=k
                fname=os.path.split(fname)[1]
                if not os.path.exists(save_path):
                   os.makedirs(save_path)
                os.chdir(save_path)
                plt.savefig(fname[:-4]+'_figure_line_corrected.png', bbox_inches='tight',dpi=600)  
            plt.show()
            
#%% Code for running master analysis
master_analysis()
